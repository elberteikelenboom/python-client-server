import serial
from .Errors import *
from .Errors import _error2string


# noinspection PyPep8Naming,PyUnusedLocal
def UNUSED(*args, **kwargs):
    pass


#
# Exception class to be generated by the Server package.
#
class ServerError(Exception):
    def __init__(self, error_code, message):
        super(ServerError, self).__init__(message)
        self.error_code = error_code


#
# Define the server base class.
#
class Server(object):

    #
    # Initialize the server base class.
    #
    def __init__(self, server_type, address, handler):
        if not callable(handler):
            raise ServerError(E_HANDLER_NOT_CALLABLE, _error2string[E_HANDLER_NOT_CALLABLE])
        self._server_type = server_type
        self._address = address
        self._handler = handler

    #
    # Abstract method that must be defined in a subclass.
    #
    # This function runs the server forever.
    #
    def serve_forever(self):
        raise NotImplementedError("%s: The serve_forever() method shall be implemented in a subclass" % type(self).__name__)

    #
    # Abstract method that must be defined in a subclass.
    #
    # The serve parameter must be a callable. The server is
    # run as long as the callable returns True. Upon exit
    # any child processes / threads will be stopped.
    #
    def serve_until(self, serve):
        raise NotImplementedError("%s: The serve_until() method shall be implemented in a subclass" % type(self).__name__)

    #
    # Return a forking server instance corresponding to the specified server type.
    # The specified server type is case insensitive and can be one of:
    #
    # * tcp : create a TCP/IP socket server.
    # * unix: create a UNIX domain socket server.
    # * serial: create a serial port server.
    #
    # noinspection SpellCheckingInspection
    @classmethod
    def create_forking(cls, server_type, handler, *args, **kwargs):
        #
        # Avoid circular imports.
        #
        from .SocketServer import _ForkingTCPSocketServer, _ForkingUNIXSocketServer
        from .SerialServer import _ForkingSerialServer
        #
        # Map a server type to an instance of a corresponding server class.
        #
        server_type = server_type.lower()
        _server_type2class = {
            'tcp': lambda _handler, address, port, max_connections=1: _ForkingTCPSocketServer(server_type, _handler, address, port, max_connections),
            'unix': lambda _handler, path, max_connections=1: _ForkingUNIXSocketServer(server_type, _handler, path, max_connections),
            'serial': lambda _handler, port, baudrate=9600, bytesize=serial.EIGHTBITS, parity=serial.PARITY_NONE, stopbits=serial.STOPBITS_ONE, timeout=None, xonxoff=False, rtscts=False, write_timeout=None, dsrdtr=False, inter_byte_timeout=None, exclusive=None: _ForkingSerialServer(server_type, _handler, port, baudrate, bytesize, parity, stopbits, timeout, xonxoff, rtscts, write_timeout, dsrdtr, inter_byte_timeout, exclusive)
        }
        return _server_type2class[server_type](handler, *args, **kwargs)

    #
    # Return a threading server instance corresponding to the specified server type.
    # The specified server type is case insensitive and can be one of:
    #
    # * tcp : create a TCP/IP socket server.
    # * unix: create a UNIX domain socket server.
    # * serial: create a serial port server.
    #
    # noinspection SpellCheckingInspection
    @classmethod
    def create_threading(cls, server_type, handler, *args, **kwargs):
        #
        # Avoid circular imports.
        #
        from .SocketServer import _ThreadingTCPSocketServer, _ThreadingUNIXSocketServer
        from .SerialServer import _ThreadingSerialServer
        #
        # Map a server type to an instance of a corresponding server class.
        #
        server_type = server_type.lower()
        _server_type2class = {
            'tcp': lambda _handler, address, port, max_connections=1: _ThreadingTCPSocketServer(server_type, _handler, address, port, max_connections),
            'unix': lambda _handler, path, max_connections=1: _ThreadingUNIXSocketServer(server_type, _handler, path, max_connections),
            'serial': lambda _handler, port, baudrate=9600, bytesize=serial.EIGHTBITS, parity=serial.PARITY_NONE, stopbits=serial.STOPBITS_ONE, timeout=None, xonxoff=False, rtscts=False, write_timeout=None, dsrdtr=False, inter_byte_timeout=None, exclusive=None: _ThreadingSerialServer(server_type, _handler, port, baudrate, bytesize, parity, stopbits, timeout, xonxoff, rtscts, write_timeout, dsrdtr, inter_byte_timeout, exclusive)
        }
        return _server_type2class[server_type](handler, *args, **kwargs)

    #
    # Return an iterative server instance corresponding to the specified server type.
    # The specified server type is case insensitive and can be one of:
    #
    # * tcp : create a TCP/IP socket server.
    # * unix: create a UNIX domain socket server.
    # * serial: create a serial port server.
    #
    # noinspection SpellCheckingInspection
    @classmethod
    def create_iterative(cls, server_type, handler, *args, **kwargs):
        #
        # Avoid circular imports.
        #
        from .SocketServer import _IterativeTCPSocketServer, _IterativeUNIXSocketServer
        from .SerialServer import _IterativeSerialServer
        #
        # Map a server type to an instance of a corresponding server class.
        #
        server_type = server_type.lower()
        _server_type2class = {
            'tcp': lambda _handler, address, port: _IterativeTCPSocketServer(server_type, _handler, address, port),
            'unix': lambda _handler, path: _IterativeUNIXSocketServer(server_type, _handler, path),
            'serial': lambda _handler, port, baudrate=9600, bytesize=serial.EIGHTBITS, parity=serial.PARITY_NONE, stopbits=serial.STOPBITS_ONE, timeout=None, xonxoff=False, rtscts=False, write_timeout=None, dsrdtr=False, inter_byte_timeout=None, exclusive=None: _IterativeSerialServer(server_type, _handler, port, baudrate, bytesize, parity, stopbits, timeout, xonxoff, rtscts, write_timeout, dsrdtr, inter_byte_timeout, exclusive)
        }
        return _server_type2class[server_type](handler, *args, **kwargs)
