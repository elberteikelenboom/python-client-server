import serial
from .Errors import *
from .Errors import _error2string


# noinspection PyPep8Naming,PyUnusedLocal
def UNUSED(*args, **kwargs):
    pass


#
# Exception class to be generated by the Server.py module.
#
class ServerError(Exception):
    def __init__(self, error_code, message):
        super(ServerError, self).__init__(message)
        self.error_code = error_code


#
# Define the server base class.
#
class Server(object):

    #
    # Initialize the server base class.
    #
    def __init__(self, address, handler):
        if not callable(handler):
            raise ServerError(E_HANDLER_NOT_CALLABLE, _error2string[E_HANDLER_NOT_CALLABLE])
        self._address = address
        self._handler = handler

    #
    # Abstract method that must be defined in a subclass.
    #
    def serve_forever(self):
        raise NotImplementedError("%s: The serve_forever() method shall be implemented in a subclass" % type(self).__name__)

    #
    # Return a server instance corresponding to the specified server type.
    # The specified server type is case insensitive and can be one of:
    #
    # * tcp : create a TCP/IP socket server.
    # * unix: create a UNIX domain socket server.
    # * serial: create a serial port server.
    #
    @classmethod
    def create(cls, server_type, handler, *args, **kwargs):
        #
        # Avoid circular imports.
        #
        from .SocketServer import _TCPSocketServer, _UNIXSocketServer
        from .SerialServer import _SerialServer
        #
        # Map a server type to an instance of a corresponding server class.
        #
        _server_type2class = {
            'tcp': lambda _handler, address, port, max_connections=1: _TCPSocketServer(_handler, address, port, max_connections),
            'unix': lambda _handler, path, max_connections=1: _UNIXSocketServer(_handler, path, max_connections),
            'serial': lambda _handler, port, baudrate=9600, bytesize=serial.EIGHTBITS, parity=serial.PARITY_NONE, stopbits=serial.STOPBITS_ONE, timeout=None, xonxoff=False, rtscts=False, write_timeout=None, dsrdtr=False, inter_byte_timeout=None, exclusive=None: _SerialServer(_handler, port, baudrate, bytesize, parity, stopbits, timeout, xonxoff, rtscts, write_timeout, dsrdtr, inter_byte_timeout, exclusive)
        }
        return _server_type2class[server_type.lower()](handler, *args, **kwargs)


#
# Base class for connections.
#
class Connection(object):
    def __init__(self):
        pass

    #
    # Encode a buffer for sending. Raise an exception
    # when buffer type is invalid.
    #
    @staticmethod
    def _encode(buffer, encoding='utf8'):
        if not isinstance(buffer, (str, bytes, bytearray, memoryview)):
            raise ServerError(E_INVALID_BUFFER_TYPE, _error2string[E_INVALID_BUFFER_TYPE])
        return bytes(buffer, encoding)

    #
    # Decode a received buffer. Raise an exception
    # when the buffer type is invalid.
    #
    @staticmethod
    def _decode(buffer, encoding='utf8'):
        if not isinstance(buffer, (bytes, bytearray, memoryview)):
            raise ServerError(E_INVALID_BUFFER_TYPE, _error2string[E_INVALID_BUFFER_TYPE])
        if encoding is not None:
            decoded = str(buffer, encoding)
        else:
            decoded = bytes(buffer)
        return decoded

    #
    # Send buffer to peer. The buffer is expected
    # to be a string, which is utf8 encoded before
    # sending.
    #
    def sendall(self, buffer, encoding='utf8'):
        raise NotImplementedError("%s: The sendall() method shall be implemented in a subclass" % type(self).__name__)

    #
    # Receive data from peer. The data is expected to
    # to be utf8 encoded and is return as a string.
    #
    def receive(self, encoding='utf8'):
        raise NotImplementedError("%s: The receive() method shall be implemented in a subclass" % type(self).__name__)
